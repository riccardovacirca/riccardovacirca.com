<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="Riccardo Vacirca">
  <title>Riccardo Vacirca - linux daemon</title>
  <!-- -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism.min.css" rel="stylesheet">
  
  <!-- -->
  <style>
    pre.line-numbers {
      position: relative;
      padding-left: 3.8em;
      counter-reset: linenumber;
    }

    pre.line-numbers > code {
      position: relative;
        white-space: inherit;
    }

    .line-numbers .line-numbers-rows {
      position: absolute;
      pointer-events: none;
      top: 0;
      font-size: 100%;
      left: -3.8em;
      width: 3em; /* works for line-numbers below 1000 lines */
      letter-spacing: -1px;
      border-right: 1px solid #999;

      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;

    }

    .line-numbers-rows > span {
      pointer-events: none;
      display: block;
      counter-increment: linenumber;
    }

    .line-numbers-rows > span:before {
      content: counter(linenumber);
      color: #999;
      display: block;
      padding-right: 0.8em;
      text-align: right;
    }
  </style>
  <!-- -->
  <style>
    body {
      margin: 0;
      border-top: 4px solid #17a2b8;
      position: relative;
      font-size: 14px;
    }
    .logo {
      color: #777
    }
    .title {
      color: #444;
    }
    .sub-title {
      font-size: 18px;
      color: #aaaaaa;
    }
    main,
    footer {
      margin: 0 auto;
      max-width: 770px;
    }
    #main {
      padding-top: 30px;
    }
    .font-anton {
      font-family: 'Anton', sans-serif;
    }
    #db-diagram {
      max-width: 678px;
      max-height: 391px;
      width: 100%;
    }
    .card-body {
      padding: 5px;
    }
    td {
      vertical-align: top;
    }
    .no-bullet {
      list-style: none;
    }
    p {
      font-size: 14px;
    }
    h4 {
      font-weight: bold;
    }
    .header p {
      font-size: 14px;
    }
    .lang {
      font-size: 14px;
      font-weight: bold;
      font-family: Arial, Helvetica, sans-serif;
      color: darkorange;
    }
  </style>
</head>

<body><a name="Top"></a>
  <main>
    <div id="main" class="container">
<!-- ----------------------------------------------------------------------- -->
<h1 class="display-5 font-anton logo mb-5">
linux daemon
<div class="sub-title">APR - Apache Portable Runtime</div>
<div class="lang">italiano</div>
</h1>
<!-- ----------------------------------------------------------------------- -->
<a name="index"></a>
<h4 class="display-5 logo">Indice</h4>
<div class="contents">
<ul class="no-bullet">
<li><a href="#intro">Introduzione</a></li>
<li><a href="#skeleton">Skeleton dell'applicazione</a></li>
<li><a href="#data_structures">Strutture dati</a></li>
<li><a href="#main_function">Funzione main</a></li>
<li><a href="#application_logic">Logica applicativa</a></li>
<li><a href="#helper">Funzioni helper</a></li>
<li><a href="#makefile">Makefile</a></li>
<li><a href="#installation">Installazione</a></li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</div>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="intro"></a>
<div class="header">
<p>
Next: <a href="#skeleton" accesskey="n" rel="next">Skeleton dell'applicazione</a>,
Previous: -,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Introduzione</h4>
<p>
Un daemon in ambiente Linux è un processo in background che opera senza
l'interazione diretta dell'utente. Questi programmi eseguono varie funzioni
vitali per il sistema operativo o per altre applicazioni, come la gestione
dei servizi di rete, la manutenzione del sistema o l'esecuzione di compiti
pianificati. I daemon vengono avviati durante il boot del sistema e rimangono
in esecuzione per tutta la durata del sistema operativo, offrendo servizi e
funzionalità senza la necessità di un'interfaccia utente diretta.
Solitamente, risiedono nella directory <code>/etc/init.d</code> o
<code>/etc/systemd/system</code> e possono essere gestiti utilizzando comandi
specifici come <code>systemctl</code> per <code>Systemd</code> o service per
<code>System V</code>.
In questo  contesto presentiamo un daemon linux sviluppato sul runtime Apache
APR con interfaccia di rete HTTP basata sulla libreria Mongoose HTTP server.
</p>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="skeleton"></a>
<div class="header">
<p>
Next: <a href="#data_structures" accesskey="n" rel="next">Strutture dati</a>,
Previous: <a href="#intro" accesskey="n" rel="next">Introduzione</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Skeleton dell'applicazione</h4>
<p><b>daemon.c</b></p>
<pre><code class="language-c">#include "..."

// Strutture dati
typedef struct dbd_t {...} dbd_t;
typedef struct logger_t {...} logger_t;
typedef struct context_t {...} context_t;
volatile sig_atomic_t server_run = 1;

// Funzioni helper
context_t* context_alloc(apr_pool_t *mp) {...}
void context_destroy(context_t *ctx) {...}
void signal_cb(int signum) {...}
typedef void(*sighd_t)(int s);
void signal_handler(struct sigaction *sa, sighd_t signal_cb) {...}
void daemonize() {...}

// Funzioni della logica applicativa
void request_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {...}
int parse_args(context_t *ctx, int argc, char *argv[], char **err) {...}
int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {...}

// Funzione main
int main(int argc, char **argv) {...}
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="data_structures"></a>
<div class="header">
  <p>
    Next: <a href="#main_function" accesskey="n" rel="next">Funzione main</a>,
    Previous: <a href="#skeleton" accesskey="n" rel="next">Skeleton dell'applicazione</a>,
    Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
    [<a href="#index" title="Indice" rel="contents">Contents</a>]
    [<a href="/" title="Home" rel="index">Home</a>]
  </p>
</div>
<h4 class="chapter mb-3">Strutture dati</h4>
<p></p>
<pre><code class="language-c">// #include "..."

// Strutture dati

typedef struct dbd_t {
  const char *err;
  const apr_dbd_driver_t *drv;
  apr_dbd_t *hdl;
  apr_dbd_transaction_t *trx;
} dbd_t;

typedef struct logger_t {
  apr_pool_t *pool;
  apr_file_t *fh;
  const char *fname;
  apr_thread_mutex_t *mutex;
} logger_t;

typedef struct context_t {
  apr_pool_t *pool;
  const char *host;
  const char *port;
  const char *addr;
  const char *timeout;
  const char *max_threads;
  const char *log_file;
  const char *dbd_driver;
  const char *dbd_conn_s;
  const char *upload_dir;
  logger_t *logger;
} context_t;

volatile sig_atomic_t server_run = 1;

// typedef void(*sighd_t)(int s);

// Funzioni helper
// context_t* context_alloc(apr_pool_t *mp) {...}
// void context_destroy(context_t *ctx) {...}
// void signal_cb(int signum) {...}
// void signal_handler(struct sigaction *sa, sighd_t signal_cb) {...}
// void daemonize() {...}

// Funzioni della logica applicativa
// void request_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {...}
// int parse_args(context_t *ctx, int argc, char *argv[], char **err) {...}
// int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {...}

// Funzione main
// int main(int argc, char **argv) {...}
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="main_function"></a>
<div class="header">
<p>
Next: <a href="#logic" accesskey="n" rel="next">Logica applicativa</a>,
Previous: <a href="#data_structures" accesskey="n" rel="prev">Strutture dati</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Funzione main</h4>
<p></p>
<pre><code class="language-c">// #include "..."

// Strutture dati
// typedef struct dbd_t {...} dbd_t;
// typedef struct logger_t {...} logger_t;
// typedef struct context_t {...} context_t;
// volatile sig_atomic_t server_run = 1;

// Funzioni helper
// context_t* context_alloc(apr_pool_t *mp) {...}
// void context_destroy(context_t *ctx) {...}
// void signal_cb(int signum) {...}
// typedef void(*sighd_t)(int s);
// void signal_handler(struct sigaction *sa, sighd_t signal_cb) {...}
// void daemonize() {...}

// Funzioni della logica applicativa
// void request_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {...}
// int parse_args(context_t *ctx, int argc, char *argv[], char **err) {...}
// int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {...}

// Funzione main

int main(int argc, char **argv) {

  // Inizializzo il valore di ritorno
  // della funzione

  int res = 1;

  // Inizializzo le variabili globali
  // della funzione

  apr_pool_t *mp;
  apr_status_t rv;
  char *err = NULL;
  struct sigaction sa;
  context_t *ctx;
  struct mg_mgr mgr;

  // Inizializzo lo stato
  // della funzione

  struct state_t {
    int init, pool, context;
  } st = {0, 0, 0};

  // Definisco la logica applicativa
  // della funzione

  do {

    // Registro la  funzione di callback
    // associata all'evento di terminazione
    
    signal_handler(&sa, signal_cb);

    // Inizializzo le strutture dati del runtime APR
    
    rv = apr_initialize();
    st.init = rv == APR_SUCCESS;
    if (!st.init) {
      break;
    }

    // Inizializzo il pool di memoria
    
    rv = apr_pool_create(&mp, NULL);
    st.pool = rv == APR_SUCCESS;
    if (!st.pool) {
      break;
    }

    // Alloco il context del servizio
    // Il context definisce una struttura dati globale
    // condivisa tra le funzioni del servizio
    
    ctx = context_alloc(mp);
    st.context = ctx != NULL;
    if (!st.context) {
      break;
    }

    // Inizializzo il context del servizio
    
    st.context = context_init(mp, &ctx, argc, argv, &err);
    if (!st.context) {
      break;
    }

    // Se richiesta una connessione con un server di database
    // inizializzo le strutture dati DBD
    
    if (ctx->dbd_driver != NULL) {
      if (ctx->dbd_conn_s != NULL) {
        apr_dbd_init(mp);
      }
    }

    // Eseguo in background il servizio
    
    daemonize();

    // Metto in ascolto il servizio sulla porta e IP
    // specificati in fase di avvio del servizio
    
    mg_mgr_init(&mgr);
    mg_http_listen(&mgr, ctx->addr, request_handler, (void*)ctx);
    
    // Avvio il main loop del servizio
    
    while (server_run) {
      mg_mgr_poll(&mgr, 1000);
    }
    
    sleep(2);
    mg_mgr_free(&mgr);
    
    // In uscita termino la struttura dati del servizio
    
    context_destroy(ctx);

    // Setto il valore di uscita    
    
    res = 0;

  } while (0);

  // Gestione degli errori

  if (res) {
    if (!st.init) {
      printf("APR initialization error\n");
    } else if (!st.pool) {
      printf("APR memory error\n");
    } else if (!st.context) {
      if (err != NULL) {
        printf("%s.\n", err);
      } else {
        printf("Daemon context error\n");
      }
    } else {
      printf("Daemon general error\n");
    }
  }

  // Rilascio delle risorse allocate

  if (st.init) {
    if (st.pool) {
      apr_pool_destroy(mp);
    }
    apr_terminate();
  }

  // Valore di ritorno
  
  return res;
}
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="logic"></a>
<div class="header">
  <p>
    Next: <a href="#helper" accesskey="n" rel="next">Funzioni helper</a>,
    Previous: <a href="#main_function" accesskey="p" rel="prev">Funzione main</a>,
    Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
    [<a href="#index" title="Indice" rel="contents">Contents</a>]
    [<a href="/" title="Home" rel="index">Home</a>]
  </p>
</div>
<h4 class="chapter mb-3">Logica applicativa</h4>
<pre><code class="language-c">// #include "..."

// Strutture dati
// typedef struct dbd_t {...} dbd_t;
// typedef struct logger_t {...} logger_t;
// typedef struct context_t {...} context_t;
// volatile sig_atomic_t server_run = 1;

// Funzioni helper
// context_t* context_alloc(apr_pool_t *mp) {...}
// void context_destroy(context_t *ctx) {...}
// void signal_cb(int signum) {...}
// typedef void(*sighd_t)(int s);
// void signal_handler(struct sigaction *sa, sighd_t signal_cb) {...}
// void daemonize() {...}

// Funzioni della logica applicativa

void request_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {

  int err = 0;
  apr_pool_t *mp;
  const char ctype[] = "Content-Type: text/plain\r\n";
  context_t *ctx;
  struct mg_http_message *hm;
  apr_status_t rv;
  
  struct state_t {
    int context, init, pool;
  } st = {0, 0, 0};
  
  do {
    if (ev == MG_EV_HTTP_MSG) {
      
      err = 1;
      
      hm = (struct mg_http_message*)ev_data;
      
      if (strncmp(hm->uri.ptr, "/api/hello", 10) != 0) {
        break;
      }
      
      ctx = (context_t*)fn_data;
      st.context = ctx != NULL;
      if (!st.context) {
        break;
      }
      
      rv = apr_initialize();
      st.init = rv == APR_SUCCESS;
      if (!st.init) {
        break;
      }
      
      rv = apr_pool_create(&mp, NULL);
      st.pool = rv == APR_SUCCESS;
      if (!st.pool) {
        break;
      }
      
      mg_http_reply(c, 200, ctype, "Hello, World!\n");

      err = 0;
    }
  } while (0);
  
  if (err) {
    if (!st.context) {
      mg_http_reply(c, 500, ctype, "Context error.\n");
    } else if (!st.init) {
      mg_http_reply(c, 500, ctype, "APR initialization error.\n");
    } else if (!st.pool) {
      mg_http_reply(c, 500, ctype, "APR memory error.\n");
    } else {
      mg_http_reply(c, 500, ctype, "General error.\n");
    }
  }

  if (st.pool) {
    apr_pool_destroy(mp);
  }
  if(st.init) {
    apr_terminate();
  }

  (void)fn_data;
}

int parse_args(context_t *ctx, int argc, char *argv[], char **err) {
  
  int res = 0;
  
  struct state_t {
    int input, args_format, host, port, log_file;
  } st = {0, 0, 0, 0, 0};
  
  do {
    st.input = ctx != NULL && argv != NULL && argc > 1 && ((argc - 1) % 2) == 0;
    if (!st.input) {
      break;
    }
    
    for (int i = 1; i < argc; i += 2) {
      
      st.args_format = strlen(argv[i]) == 2;
      if (!st.args_format) {
        break;
      }
      
      if (argv[i][1] == 'h') {
        ctx->host = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'p') {
        ctx->port = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 't') {
        ctx->timeout = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'T') {
        ctx->max_threads = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'l') {
        ctx->log_file = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'd') {
        ctx->dbd_driver = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'D') {
        ctx->dbd_conn_s = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'u') {
        ctx->upload_dir = apr_psprintf(ctx->pool, argv[i+1]);
      }
    }
    
    if (!st.args_format) {
      break;
    }
    
    st.host = ctx->host != NULL;
    if (!st.host) {
      break;
    }
    
    st.port = ctx->port != NULL;
    if (!st.port) {
      break;
    }
    
    st.log_file = ctx->log_file != NULL;
    if (!st.log_file) {
      break;
    }
    
    res = 1;
  
  } while (0);

  if (!res) {
    if (!st.input) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid input.", __FUNCTION__);
    } else if (!st.args_format) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid arguments format.", __FUNCTION__);
    } else if (!st.host) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid host address.", __FUNCTION__);
    } else if (!st.port) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid port number.", __FUNCTION__);
    } else if (!st.log_file) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid log file.", __FUNCTION__);
    } else {
      *err = apr_psprintf(ctx->pool, "%s: General error.", __FUNCTION__);
    }
  }
  
  return res;
}

int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {

  int res = 0;

  apr_status_t rv;
  apr_thread_mutex_t *log_mutex;
  
  struct state_t {
    int input, context, args, addr, mutex, logger;
  } st = {0, 0, 0, 0, 0, 0};
  
  do {
    
    st.input = mp != NULL && *ctx != NULL && argv != NULL && argc > 1;
    if (!st.input) {
      break;
    }
    
    st.args = parse_args(*ctx, argc, argv, err);
    if (!st.args) {
      ctx = NULL;
      break;
    }

    (*ctx)->addr = apr_psprintf(mp, "%s:%s", (*ctx)->host, (*ctx)->port);
    st.addr = (*ctx)->addr != NULL;
    if (!st.addr) {
      break;
    }

    // rv = apr_thread_mutex_create(&log_mutex, APR_THREAD_MUTEX_DEFAULT, mp);
    // st.mutex = rv == APR_SUCCESS;
    // if (!st.mutex) {
    //   break;
    // }

    // (*ctx)->logger = log_init(mp, (*ctx)->log_file, log_mutex);
    // st.logger = (*ctx)->logger != NULL;
    // if (!st.logger) {
    //   break;
    // }

    res = 1;

  } while (0);

  if (!res) {
    if (!st.input) {
      *err = apr_psprintf(mp, "%s: Invalid input", __FUNCTION__);
    } else if(!st.args) {
      if (err == NULL) {
        *err = apr_psprintf(mp, "%s: Invalid arguments", __FUNCTION__);
      }
    } else {
      *err = apr_psprintf(mp, "%s: General error", __FUNCTION__);
    }
  }

  return res;
}

// Funzione main
// int main(int argc, char **argv) {...}
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="helper"></a>
<div class="header">
<p>
Next: <a href="#makefile" accesskey="n" rel="next">Makefile</a>,
Previous: <a href="#logic" accesskey="p" rel="prev">Logica applicativa</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Funzioni helper</h4>
<pre><code class="language-c">// #include "..."

// Strutture dati
// typedef struct dbd_t {...} dbd_t;
// typedef struct logger_t {...} logger_t;
// typedef struct context_t {...} context_t;
// volatile sig_atomic_t server_run = 1;

// Funzioni helper

context_t* context_alloc(apr_pool_t *mp) {
  context_t *res = (context_t*)apr_palloc(mp, sizeof(context_t));
  if (res != NULL) {
    res->pool = mp;
    res->host = NULL;
    res->port = NULL;
    res->timeout = NULL;
    res->max_threads = NULL;
    res->log_file = NULL;
    res->logger = NULL;
    res->dbd_driver = NULL;
    res->dbd_conn_s = NULL;
    res->upload_dir = NULL;
    res->addr = NULL;
  }
  return res;
}

void context_destroy(context_t *ctx) {
  if (ctx->logger != NULL) {
    if (ctx->logger->mutex != NULL) {
      apr_thread_mutex_destroy(ctx->logger->mutex);
    }
    if (ctx->logger->fh != NULL) {
      apr_file_close(ctx->logger->fh);
    }
  }
}

void signal_cb(int signum) {
  if (signum == SIGTERM || signum == SIGINT) {
    server_run = 0;
  }
}

typedef void(*sighd_t)(int s);

void signal_handler(struct sigaction *sa, sighd_t signal_cb) {
  sa->sa_handler = signal_cb;
  sigemptyset(&sa->sa_mask);
  sa->sa_flags = 0;
  sigaction(SIGTERM, sa, NULL);
  sigaction(SIGINT, sa, NULL);
}

void daemonize() {
  pid_t pid, sid;
  pid = fork();
  if (pid < 0) {
    perror("Fork failed");
    exit(1);
  }
  if (pid > 0) {
    exit(0);
  }
  sid = setsid();
  if (sid < 0) {
    perror("Error creating new session");
    exit(1);
  }
  pid = fork();
  if (pid < 0) {
    perror("Second fork failed");
    exit(1);
  }
  if (pid > 0) {
    exit(0);
  }
  if (chdir("/") < 0) {
    perror("Error changing working directory");
    exit(1);
  }
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);
}

// Funzioni della logica applicativa
// void request_handler(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {...}
// int parse_args(context_t *ctx, int argc, char *argv[], char **err) {...}
// int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {...}

// Funzione main
// int main(int argc, char **argv) {...}
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="makefile"></a>
<div class="header">
<p>
Next: <a href="#installation" accesskey="n" rel="next">Installazione</a>,
Previous: <a href="#helper" accesskey="p" rel="prev">Funzioni helper</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Makefile</h4>
<pre><code class="language-makefile">CC=gcc
CFLAGS=-std=gnu99
INCLUDES=-I. -I/usr/include/apr-1.0
LD_FLAGS=-lapr-1 -laprutil-1

all:
	$(CC) $(CFLAGS) -o daemon mongoose.c daemon.c $(INCLUDES) $(LD_FLAGS)

test:
	./daemon -h 0.0.0.0 -p 8088 -l ./daemon.log

.PHONY: all test
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="installation"></a>
<div class="header">
<p>
Next: <a href="#copyright" accesskey="n" rel="next">Copyright</a>,
Previous: <a href="#makefile" accesskey="p" rel="prev">Makefile</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Installazione</h4>
<pre><code class="language-makefile">
</code></pre>
<!-- ----------------------------------------------------------------------- -->
<hr class="mt-5">
<a name="copyright"></a>
<div class="header">
<p>
Next: -,
Previous: <a href="#installation" accesskey="p" rel="prev">Installazione</a>,
Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp;
[<a href="#index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Copyright</h4>
<pre><code class="language-bash">Copyright 2023-2024 Riccardo Vacirca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>

    </div>
  </main>
  <footer>
    <div class="container">
      <!----------------------------------------------------------------------------->
      <hr class="mt-5">
      <p class="mb-3 text-muted">
        &copy; 2020-2023 Riccardo Vacirca
        <a href="https://www.linkedin.com/in/riccardovacirca"><i class="fa fa-linkedin-square"></i></a>
        <a href="https://github.com/riccardovacirca"><i class="fa fa-git-square"></i></a><br>
        <small>All right reserved</small>
      </p>
      <!----------------------------------------------------------------------------->
    </div>
  </footer>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.20.0/axios.min.js"
    integrity="sha512-quHCp3WbBNkwLfYUMd+KwBAgpVukJu5MncuQaWXgCrfgcxCJAq/fo+oqrRKOj+UKEmyMCG3tb8RB63W+EmrOBg=="
    crossorigin="anonymous"></script>
  <script>/** SQL highlighter for PrismJS <http://prismjs.com/> * @author Petros Kyladitis */ Prism.languages.sql = { comment: { pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|((--)|(\/\/)).*?(\r?\n|$))/g, lookbehind: !0 }, string: /("|')(\\?.)*?\1/g, keyword: /\b(ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMPORARY|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\b/gi, boolean: /\b(TRUE|FALSE|NULL)\b/gi, number: /\b-?(0x)?\d*\.?[\da-f]+\b/g, operator: /\b(ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b|[-+]{1}|!|=?&lt;|=?&gt;|={1}|(&amp;){1,2}|\|?\||\?|\*|\//gi, ignore: /&(lt|gt|amp);/gi, punctuation: /[;[\]()`,.]/g };</script>
  <script>/*$('#toast-1').toast('show');$('#toast-2').toast('show');*/</script>
  <script>
    (function () {

if (typeof self === 'undefined' || !self.Prism || !self.document) {
  return;
}

/**
 * Class name for <pre> which is activating the plugin
 * @type {String}
 */
var PLUGIN_CLASS = 'line-numbers';

/**
 * Resizes line numbers spans according to height of line of code
 * @param  {Element} element <pre> element
 */
var _resizeElement = function (element) {
  var codeStyles = getStyles(element);
  var whiteSpace = codeStyles['white-space'];

  if (whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line') {
    var codeElement = element.querySelector('code');
    var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
    var lineNumberSizer = element.querySelector('.line-numbers-sizer');
    var codeLines = element.textContent.split('\n');

    if (!lineNumberSizer) {
      lineNumberSizer = document.createElement('span');
      lineNumberSizer.className = 'line-numbers-sizer';

      codeElement.appendChild(lineNumberSizer);
    }

    lineNumberSizer.style.display = 'block';

    codeLines.forEach(function (line, lineNumber) {
      lineNumberSizer.textContent = line || '\n';
      var lineSize = lineNumberSizer.getBoundingClientRect().height;
      lineNumbersWrapper.children[lineNumber].style.height = lineSize + 'px';
    });

    lineNumberSizer.textContent = '';
    lineNumberSizer.style.display = 'none';
  }
};

/**
 * Returns style declarations for the element
 * @param {Element} element
 */
var getStyles = function (element) {
  if (!element) {
    return null;
  }

  return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
};

window.addEventListener('resize', function () {
  Array.prototype.forEach.call(document.querySelectorAll('pre.' + PLUGIN_CLASS), _resizeElement);
});

Prism.hooks.add('complete', function (env) {
  if (!env.code) {
    return;
  }

  // works only for <code> wrapped inside <pre> (not inline)
  var pre = env.element.parentNode;
  // Original regex check for class, leaving it here 
  // for its redundancy check
  var clsReg = /\s*\bline-numbers\b\s*/;
  // New regex check for opt-out class
  var clsRegB = /\s*\bno-line-numbers\b\s*/;

  if (env.element.querySelector(".line-numbers-rows")) {
    // Abort if line numbers already exists
    return;
  }
  
  // Added to facilitate opting out
  if (clsRegB.test(pre.className)) {
    // Respect the opt-out
    return;
  }

  if (clsReg.test(env.element.className)) {
    // Remove the class "line-numbers" from the <code>
    env.element.className = env.element.className.replace(clsReg, ' ');
  }
  if (!clsReg.test(pre.className)) {
    // Add the class "line-numbers" to the <pre>
    pre.className += ' line-numbers';
  }

  var match = env.code.match(/\n(?!$)/g);
  var linesNum = match ? match.length + 1 : 1;
  var lineNumbersWrapper;

  var lines = new Array(linesNum + 1);
  lines = lines.join('<span></span>');

  lineNumbersWrapper = document.createElement('span');
  lineNumbersWrapper.setAttribute('aria-hidden', 'true');
  lineNumbersWrapper.className = 'line-numbers-rows';
  lineNumbersWrapper.innerHTML = lines;

  if (pre.hasAttribute('data-start')) {
    pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
  }

  env.element.appendChild(lineNumbersWrapper);

  _resizeElement(pre);
});

}());
  </script>
</body>

</html>