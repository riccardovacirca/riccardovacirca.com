<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="Riccardo Vacirca">
  <title>riccardovacirca.com - linux daemon</title>
  <!-- -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism-tomorrow.min.css" rel="stylesheet">
  <!-- -->
  <style>
  body {
    margin: 0;
    border-top: 4px solid #17a2b8;
    position: relative;
    font-size:14px;
  }
  .logo {
    color: #777
  }
  .title {
    color: #444;
  }
  .sub-title{
    font-size: 18px;
    line-height: 18px;
    color: #cccccc;
  }
  main, footer {
    margin: 0 auto;
    max-width: 770px;
  }
  #main {
    padding-top: 30px;
  }
  .font-anton {
    font-family:'Anton', sans-serif;
  }
  #db-diagram {
    max-width: 678px;
    max-height: 391px;
    width: 100%;
  }
  .card-body {
    padding: 5px;
  }
  td {
    vertical-align: top;
  }
  .no-bullet {
    list-style: none;
  }
  p {
    font-size: 16px;
  }
  h4 {
    font-weight: bold;
  }
  .header p {
    font-size: 12px;
  }
  .lang {
    font-size: 16px;
    font-weight: bold;
    font-family: Arial, Helvetica, sans-serif;
    color: darkorange;
  }
  </style>
</head>
<body>
  <main>
    <div id="main" class="container">
      <!-- ----------------------------------------------------------------- -->
      <h1 class="display-5 font-anton logo mb-5">
        linux daemon
        <div class="sub-title">apr/mongoose linux based daemon</p>
        <div class="lang">italiano</div>
      </h1>
      <!-- ----------------------------------------------------------------- -->
      <a name="apr_index"></a>
      <h4 class="display-5 logo">Indice</h4>
      <div class="contents">
        <ul class="no-bullet">
          <li><a href="#daemon_skeleton">Daemon skeleton</a></li>
          <li><a href="#daemon_code">Daemon code</a></li>
        </ul>
      </div>
      <!-- DAEMON CODE START ----------------------------------------------- -->
      <hr class="mt-5">
      <a name="Top"></a><a name="daemon_skeleton"></a>
      <div class="header">
        <p>
          Next: <a href="#prossimo_articolo" accesskey="n" rel="next">prossimo articolo</a>,
          Previous: -,
          Up: - &nbsp;
          [<a href="#apr_index" title="Indice" rel="contents">Contents</a>]
          [<a href="/" title="Home" rel="index">Home</a>]
        </p>
      </div>
      <h4 class="chapter mb-3">Daemon skeleton</h4>
      <pre><code class="language-c">// Gestore dei logs
typedef struct logger_t logger_t;

// Struttura dati principale del daemon
typedef struct server_t server_t;

// Struttura dati della response
typedef struct response_t response_t;

// Struttura dati passata al request handler
typedef struct service_t service_t;

// Stato di esecuzione del daemon
volatile sig_atomic_t ns_server_run = 1;

// Callback del daemon invocata dal request handler
void server_callback(struct mg_connection *c, int ev, void *ev_data, void *fn_data);

// Signal handler associato al segnale di uscita
void sighd_fn(int signum);

// Funzione principale del daemon
int main(int argc, const char *argv[]);
</code></pre>
      <!-- DAEMON SKELETON END --------------------------------------------- -->
      <!-- DAEMON CODE START ----------------------------------------------- -->
      <hr class="mt-5">
      <a name="Top"></a><a name="daemon_code"></a>
      <div class="header">
        <p>
          Next: <a href="#prossimo_articolo" accesskey="n" rel="next">prossimo articolo</a>,
          Previous: -,
          Up: - &nbsp;
          [<a href="#apr_index" title="Indice" rel="contents">Contents</a>]
          [<a href="/" title="Home" rel="index">Home</a>]
        </p>
      </div>
      <h4 class="chapter mb-3">Daemon code</h4>
      <pre><code class="language-c">
#include "apr.h"
#include "apr_general.h"
#include "apr_pools.h"
#include "apr_strings.h"
#include "apr_tables.h"
#include "apr_file_info.h"
#include "apr_file_io.h"
#include "apr_dbd.h"

#include "mongoose.h"

#include "stdio.h"
#include "errno.h"
#include "time.h"
#include "syscall.h"
#include "unistd.h"
#include "stdlib.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "sys/file.h"
#include "string.h"
#include "signal.h"

typedef struct dbd_t {
  const char *err;
  const apr_dbd_driver_t *drv;
  apr_dbd_t *hdl;
  apr_dbd_transaction_t *trx;
} dbd_t;

typedef struct logger_t {
  apr_pool_t *pool;
  apr_file_t *fh;
  const char *fname;
  apr_thread_mutex_t *mutex;
} logger_t;

typedef struct context_t {
  apr_pool_t *pool;
  const char *host;
  const char *port;
  const char *addr;
  const char *timeout;
  const char *max_threads;
  const char *log_file;
  const char *dbd_driver;
  const char *dbd_conn_s;
  const char *upload_dir;
  logger_t *logger;
} context_t;

volatile sig_atomic_t server_run = 1;

context_t* context_alloc(apr_pool_t *mp) {
  context_t *res = (context_t*)apr_palloc(mp, sizeof(context_t));
  if (res != NULL) {
    res->pool = mp;
    res->host = NULL;
    res->port = NULL;
    res->timeout = NULL;
    res->max_threads = NULL;
    res->log_file = NULL;
    res->logger = NULL;
    res->dbd_driver = NULL;
    res->dbd_conn_s = NULL;
    res->upload_dir = NULL;
    res->addr = NULL;
  }
  return res;
}

void context_destroy(context_t *ctx) {
  if (ctx->logger != NULL) {
    if (ctx->logger->mutex != NULL) {
      apr_thread_mutex_destroy(ctx->logger->mutex);
    }
    if (ctx->logger->fh != NULL) {
      apr_file_close(ctx->logger->fh);
    }
  }
}

void sighd_fn(int signum) {
  if (signum == SIGTERM || signum == SIGINT) {
    server_run = 0;
  }
}

typedef void(*sighd_t)(int s);

void sighd(struct sigaction *sa, sighd_t sighd_fn) {
  sa->sa_handler = sighd_fn;
  sigemptyset(&sa->sa_mask);
  sa->sa_flags = 0;
  sigaction(SIGTERM, sa, NULL);
  sigaction(SIGINT, sa, NULL);
}

void daemonize() {
  pid_t pid, sid;
  pid = fork();
  if (pid < 0) {
    perror("Fork failed");
    exit(1);
  }
  if (pid > 0) {
    exit(0);
  }
  sid = setsid();
  if (sid < 0) {
    perror("Error creating new session");
    exit(1);
  }
  pid = fork();
  if (pid < 0) {
    perror("Second fork failed");
    exit(1);
  }
  if (pid > 0) {
    exit(0);
  }
  if (chdir("/") < 0) {
    perror("Error changing working directory");
    exit(1);
  }
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);
}

void cb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {

  int err = 0;
  apr_pool_t *mp;
  const char ctype[] = "Content-Type: text/plain\r\n";
  context_t *ctx;
  struct mg_http_message *hm;
  apr_status_t rv;
  
  struct state_t {
    int context, init, pool;
  } st = {0, 0, 0};
  
  do {
    if (ev == MG_EV_HTTP_MSG) {
      
      err = 1;
      
      hm = (struct mg_http_message*)ev_data;
      
      if (strncmp(hm->uri.ptr, "/api/hello", 10) != 0) {
        break;
      }
      
      ctx = (context_t*)fn_data;
      st.context = ctx != NULL;
      if (!st.context) {
        break;
      }
      
      rv = apr_initialize();
      st.init = rv == APR_SUCCESS;
      if (!st.init) {
        break;
      }
      
      rv = apr_pool_create(&mp, NULL);
      st.pool = rv == APR_SUCCESS;
      if (!st.pool) {
        break;
      }
      
      mg_http_reply(c, 200, ctype, "Hello, World!\n");

      err = 0;
    }
  } while (0);
  
  if (err) {
    if (!st.context) {
      mg_http_reply(c, 500, ctype, "Context error.\n");
    } else if (!st.init) {
      mg_http_reply(c, 500, ctype, "APR initialization error.\n");
    } else if (!st.pool) {
      mg_http_reply(c, 500, ctype, "APR memory error.\n");
    } else {
      mg_http_reply(c, 500, ctype, "General error.\n");
    }
  }

  if (st.pool) {
    apr_pool_destroy(mp);
  }
  if(st.init) {
    apr_terminate();
  }

  (void)fn_data;
}

int parse_args(context_t *ctx, int argc, char *argv[], char **err) {
  
  int res = 0;
  
  struct state_t {
    int input, args_format, host, port, log_file;
  } st = {0, 0, 0, 0, 0};
  
  do {
    st.input = ctx != NULL && argv != NULL && argc > 1 && ((argc - 1) % 2) == 0;
    if (!st.input) {
      break;
    }
    
    for (int i = 1; i < argc; i += 2) {
      
      st.args_format = strlen(argv[i]) == 2;
      if (!st.args_format) {
        break;
      }
      
      if (argv[i][1] == 'h') {
        ctx->host = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'p') {
        ctx->port = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 't') {
        ctx->timeout = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'T') {
        ctx->max_threads = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'l') {
        ctx->log_file = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'd') {
        ctx->dbd_driver = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'D') {
        ctx->dbd_conn_s = apr_psprintf(ctx->pool, argv[i+1]);
      } else if (argv[i][1] == 'u') {
        ctx->upload_dir = apr_psprintf(ctx->pool, argv[i+1]);
      }
    }
    
    if (!st.args_format) {
      break;
    }
    
    st.host = ctx->host != NULL;
    if (!st.host) {
      break;
    }
    
    st.port = ctx->port != NULL;
    if (!st.port) {
      break;
    }
    
    st.log_file = ctx->log_file != NULL;
    if (!st.log_file) {
      break;
    }
    
    res = 1;
  
  } while (0);

  if (!res) {
    if (!st.input) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid input.", __FUNCTION__);
    } else if (!st.args_format) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid arguments format.", __FUNCTION__);
    } else if (!st.host) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid host address.", __FUNCTION__);
    } else if (!st.port) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid port number.", __FUNCTION__);
    } else if (!st.log_file) {
      *err = apr_psprintf(ctx->pool, "%s: Invalid log file.", __FUNCTION__);
    } else {
      *err = apr_psprintf(ctx->pool, "%s: General error.", __FUNCTION__);
    }
  }
  
  return res;
}


int context_init(apr_pool_t *mp, context_t **ctx, int argc, char *argv[], char **err) {

  int res = 0;

  apr_status_t rv;
  apr_thread_mutex_t *log_mutex;
  
  struct state_t {
    int input, context, args, addr, mutex, logger;
  } st = {0, 0, 0, 0, 0, 0};
  
  do {
    
    st.input = mp != NULL && *ctx != NULL && argv != NULL && argc > 1;
    if (!st.input) {
      break;
    }
    
    st.args = parse_args(*ctx, argc, argv, err);
    if (!st.args) {
      ctx = NULL;
      break;
    }

    (*ctx)->addr = apr_psprintf(mp, "%s:%s", (*ctx)->host, (*ctx)->port);
    st.addr = (*ctx)->addr != NULL;
    if (!st.addr) {
      break;
    }

    // rv = apr_thread_mutex_create(&log_mutex, APR_THREAD_MUTEX_DEFAULT, mp);
    // st.mutex = rv == APR_SUCCESS;
    // if (!st.mutex) {
    //   break;
    // }

    // (*ctx)->logger = log_init(mp, (*ctx)->log_file, log_mutex);
    // st.logger = (*ctx)->logger != NULL;
    // if (!st.logger) {
    //   break;
    // }

    res = 1;

  } while (0);

  if (!res) {
    if (!st.input) {
      *err = apr_psprintf(mp, "%s: Invalid input", __FUNCTION__);
    } else if(!st.args) {
      if (err == NULL) {
        *err = apr_psprintf(mp, "%s: Invalid arguments", __FUNCTION__);
      }
    } else {
      *err = apr_psprintf(mp, "%s: General error", __FUNCTION__);
    }
  }

  return res;
}

int main(int argc, char **argv) {

  // Inizializzazione del valore di ritorno

  int res = 1;

  // Inizializzazione delle variabili globali

  apr_pool_t *mp;
  apr_status_t rv;
  char *err = NULL;
  struct sigaction sa;
  context_t *ctx;
  struct mg_mgr mgr;

  // Inizializzazione dello stato

  struct state_t {
    int init, pool, context;
  } st = {0, 0, 0};

  // Logica applicativa

  do {

    sighd(&sa, sighd_fn);

    rv = apr_initialize();
    st.init = rv == APR_SUCCESS;
    if (!st.init) {
      break;
    }

    rv = apr_pool_create(&mp, NULL);
    st.pool = rv == APR_SUCCESS;
    if (!st.pool) {
      break;
    }

    ctx = context_alloc(mp);
    st.context = ctx != NULL;
    if (!st.context) {
      break;
    }

    st.context = context_init(mp, &ctx, argc, argv, &err);
    if (!st.context) {
      break;
    }

    if (ctx->dbd_driver != NULL) {
      if (ctx->dbd_conn_s != NULL) {
        apr_dbd_init(mp);
      }
    }

    //daemonize();

    mg_mgr_init(&mgr);
    mg_http_listen(&mgr, ctx->addr, cb, (void*)ctx);
    while (server_run) {
      mg_mgr_poll(&mgr, 1000);
    }
    sleep(2);
    mg_mgr_free(&mgr);
    
    context_destroy(ctx);
    
    res = 0;

  } while (0);

  // Gestione degli errori

  if (res) {
    if (!st.init) {
      printf("APR initialization error\n");
    } else if (!st.pool) {
      printf("APR memory error\n");
    } else if (!st.context) {
      if (err != NULL) {
        printf("%s.\n", err);
      } else {
        printf("Daemon context error\n");
      }
    } else {
      printf("Daemon general error\n");
    }
  }

  // Rilascio delle risorse allocate

  if (st.pool) {
    apr_pool_destroy(mp);
  }
  if (st.init) {
    apr_terminate();
  }

  // Valore di ritorno
  
  return res;
}</code></pre>
<!-- DAEMON CODE END ------------------------------------------------- -->
<!-- COMPILAZIONE START -------------------------------------------------- -->
<hr class="mt-5">
<a name="Top"></a><a name="articolo"></a>
<div class="header">
<p>
Next: <a href="#prossimo_articolo" accesskey="n" rel="next">prossimo articolo</a>,
Previous: -,
Up: - &nbsp;
[<a href="#apr_index" title="Indice" rel="contents">Contents</a>]
[<a href="/" title="Home" rel="index">Home</a>]
</p>
</div>
<h4 class="chapter mb-3">Compilazione</h4>
<pre><code class="language-shell">$ gcc -std=gnu99 -o daemon mongoose.c daemon.c -I. -I/usr/include/apr-1.0 -lapr-1 -laprutil-1
$ ./daemon -h 0.0.0.0 -p 8088 -l ./daemon.log
</code></pre>
    <!-- COMPILAZIONE END ---------------------------------------------------- -->
    <!-- ARTICOLO START -------------------------------------------------- -->
      <hr class="mt-5">
      <a name="Top"></a><a name="articolo"></a>
      <div class="header">
        <p>
          Next: <a href="#prossimo_articolo" accesskey="n" rel="next">prossimo articolo</a>,
          Previous: -,
          Up: - &nbsp;
          [<a href="#apr_index" title="Indice" rel="contents">Contents</a>]
          [<a href="/" title="Home" rel="index">Home</a>]
        </p>
      </div>
      <h4 class="chapter mb-3">Installazione</h4>
      <pre><code class="language-shell">#!/bin/bash
### BEGIN INIT INFO
# Provides:          hello
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Simple hello program
# Description:       This script runs the hello program.
### END INIT INFO

NAME="hello"
HOST="0.0.0.0"
PORT="8086"
BIN_FILE="/usr/bin/$NAME -h $HOST -p $PORT -l /var/log/$NAME.log"
PID_FILE="/var/run/$NAME.pid"

do_start() {
  if [ -f "$PID_FILE" ]; then
    echo "The $NAME service is already running."
    exit 1
  fi
  # Start the $NAME program
  $BIN_FILE &
  # Store the process ID in the PID file
  echo $! > "$PID_FILE"
  echo "Started the $NAME service."
}

do_stop() {
  if [ ! -f "$PID_FILE" ]; then
    echo "The $NAME service is not running."
    exit 1
  fi

  # Read the process ID from the PID file
  PID=$(cat "$PID_FILE")
  # Terminate the $NAME program
  kill "$PID"
  # Remove the PID file
  rm "$PID_FILE"
  echo "Stopped the $NAME service."
}

do_restart() {
  do_stop
  sleep 1
  do_start
}

do_status() {
  if [ -f "$PID_FILE" ]; then
    PID=$(cat "$PID_FILE")
    if ps -p "$PID" > /dev/null; then
        echo "The $NAME service is running (PID: $PID)."
    else
        echo "The $NAME service is not running. [1]"
    fi
  else
    echo "The $NAME service is not running. [2]"
  fi
}

case "$1" in
  start)
    do_start
    ;;
  stop)
    do_stop
    ;;
  restart)
    do_restart
    ;;
  status)
    do_status
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}"
    exit 1
    ;;
esac
</code></pre>
      <!-- ARTICOLO END ---------------------------------------------------- -->

    </div>
  </main>
  <footer>
    <div class="container">
      <!-- ----------------------------------------------------------------- -->
      <hr class="mt-5">
      <p class="mb-3 text-muted">
          &copy; 2020-2023 Riccardo Vacirca
          <a href="https://www.linkedin.com/in/riccardovacirca"><i class="fa fa-linkedin-square"></i></a>
          <a href="https://github.com/riccardovacirca"><i class="fa fa-git-square"></i></a><br>
          <small>All right reserved</small>
      </p>
      <!-- ----------------------------------------------------------------- -->
    </div>
  </footer>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.20.0/axios.min.js" integrity="sha512-quHCp3WbBNkwLfYUMd+KwBAgpVukJu5MncuQaWXgCrfgcxCJAq/fo+oqrRKOj+UKEmyMCG3tb8RB63W+EmrOBg==" crossorigin="anonymous"></script>
  <script>/** SQL highlighter for PrismJS <http://prismjs.com/> * @author Petros Kyladitis */ Prism.languages.sql={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|((--)|(\/\/)).*?(\r?\n|$))/g,lookbehind:!0},string: /("|')(\\?.)*?\1/g,keyword:/\b(ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMPORARY|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\b/gi,boolean:/\b(TRUE|FALSE|NULL)\b/gi,number:/\b-?(0x)?\d*\.?[\da-f]+\b/g,operator:/\b(ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b|[-+]{1}|!|=?&lt;|=?&gt;|={1}|(&amp;){1,2}|\|?\||\?|\*|\//gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[;[\]()`,.]/g};</script>
  <script>/*$('#toast-1').toast('show');$('#toast-2').toast('show');*/</script>
</body>
</html>
